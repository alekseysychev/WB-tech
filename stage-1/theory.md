# Теория

```text
Какой самый эффективный способ работы с объединением строк?
```

Вариант 1: +

Вариант 2: +=

Вариант 3: bytes.Buffer

Вариант 4: fmt.Sprintf

Вариант 5: strings.Join

Вариант 6: copy

Самый быстрый из адекватных вариантов - 3

---

```text
Что такое интерфейсы, как они применяются в Go?
```

Интерфейс это контракт. Применяются для внедрения зависимостей (di). Реальзуется не явно утиная-типизация

```text
Чем отличаются RWMutex от Mutex?
```

RWMutex позволяет разграничить чтение и запись. Позволяет одновременно читать при блокировке на чтение.

---

```text
Чем отличаются буферизированные и не буферизированные каналы?
```

Буферизованные каналы имеют мозможность принимать сообщения до наполнения.

---

```text
Какой размер пустой структуры struct{}{}?
```

0 байт

---

```text
Какой способ определения двух слайсов предпочтительнее? 
var a []int
a := []int{}
```

Первый вариант, так как он создаёт нулевой срез.
Второй вариант создаёт пустой срез.
append работает одинаково с обоими, но в первом можно сделать проверку a == nil

---

```text
Есть ли в Go перегрузка методов или операторов?
```

Перегрузки методов и операторов нет, но можно для обхода этого использовать интерфейсы

---

```text
В какой последовательности будут выведены элементы map[int]int?
Пример:
m[0]=1
m[1]=124
m[2]=281
```

1 124 281

---

```text
В чем разница make и new?
```

new - возвращает указатель, выделяет место в памяти, но не инициализирует
make - возвращает тип, выделяет место в памяти и инициализирует

---

```text
Сколько существует способов создать переменную типа slice или map?
```

var a []int

b := []int{}

c := new([]int)

d := make([]int, 0)

---
