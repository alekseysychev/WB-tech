       grep [OPTION...] PATTERNS [FILE...]
       grep [OPTION...] -e PATTERNS ... [FILE...]
       grep [OPTION...] -f PATTERN_FILE ... [FILE...]

DESCRIPTION
       grep  searches  for  PATTERNS  in  each  FILE.   PATTERNS is one or more patterns separated by newline characters, and grep prints each line that matches a pattern.
       Typically PATTERNS should be quoted when grep is used in a shell command.

       A FILE of “-” stands for standard input.  If no FILE is given, recursive searches examine the working directory, and nonrecursive searches read standard input.

       In addition, the variant programs egrep, fgrep and rgrep are the same as grep -E, grep -F, and grep -r,  respectively.   These  variants  are  deprecated,  but  are
       provided for backward compatibility.

OPTIONS
   Generic Program Information
       --help Output a usage message and exit.

       -V, --version
              Output the version number of grep and exit.

   Pattern Syntax
--
       -F, --fixed-strings
              Interpret PATTERNS as fixed strings, not regular expressions.

       -G, --basic-regexp
              Interpret PATTERNS as basic regular expressions (BREs, see below).  This is the default.

       -P, --perl-regexp
              Interpret  PATTERNS  as Perl-compatible regular expressions (PCREs).  This option is experimental when combined with the -z (--null-data) option, and grep -P
              may warn of unimplemented features.

   Matching Control
--
       -f FILE, --file=FILE
              Obtain  patterns from FILE, one per line.  If this option is used multiple times or is combined with the -e (--regexp) option, search for all patterns given.
              The empty file contains zero patterns, and therefore matches nothing.

       -i, --ignore-case
              Ignore case distinctions in patterns and input data, so that characters that differ only in case match each other.

       --no-ignore-case
              Do not ignore case distinctions in patterns and input data.  This is the default.  This option is useful for passing to shell scripts that already use -i, to
              cancel its effects because the two options override each other.

       -v, --invert-match
--
              Select  only those matches that exactly match the whole line.  For a regular expression pattern, this is like parenthesizing the pattern and then surrounding
              it with ^ and $.

       -y     Obsolete synonym for -i.

   General Output Control
       -c, --count
              Suppress normal output; instead print a count of matching lines for each input file.  With the -v, --invert-match  option  (see  below),  count  non-matching
              lines.

       --color[=WHEN], --colour[=WHEN]
--
              Output  a  zero  byte  (the ASCII NUL character) instead of the character that normally follows a file name.  For example, grep -lZ outputs a zero byte after
              each file name instead of the usual newline.  This option makes the output unambiguous, even in the presence of file names containing unusual characters like
              newlines.   This  option can be used with commands like find -print0, perl -0, sort -z, and xargs -0 to process arbitrary file names, even those that contain
              newline characters.

   Context Line Control
       -A NUM, --after-context=NUM
              Print NUM lines of trailing context after matching lines.  Places a line containing a group separator (--) between contiguous groups of matches.  With the -o
              or --only-matching option, this has no effect and a warning is given.

       -B NUM, --before-context=NUM
--
   File and Directory Selection
       -a, --text
              Process a binary file as if it were text; this is equivalent to the --binary-files=text option.

       --binary-files=TYPE
              If  a  file's data or metadata indicate that the file contains binary data, assume that the file is of type TYPE.  Non-text bytes indicate binary data; these
              are either output bytes that are improperly encoded for the current locale, or null input bytes when the -z option is not given.

              By default, TYPE is binary, and grep suppresses output after null input binary data is discovered,  and  suppresses  output  lines  that  contain  improperly
              encoded data.  When some output is suppressed, grep follows any output with a one-line message saying that a binary file matches.

--
              a pattern matches a file.  For example, when type is binary the pattern q$ might match q immediately followed by a null byte, even though this is not matched
              when type is text.  Conversely, when type is binary the pattern . (period) might not match a null byte.

              Warning: The -a option might output binary garbage, which can have nasty side effects if the output is a terminal and if the terminal driver interprets  some
              of  it  as  commands.   On  the  other  hand,  when  reading  files whose text encodings are unknown, it can be helpful to use -a or to set LC_ALL='C' in the
              environment, in order to find more matches even if the matches are unsafe for direct display.

       -D ACTION, --devices=ACTION
              If an input file is a device, FIFO or socket, use ACTION to process it.  By default, ACTION is read, which means that devices are read just as if  they  were
              ordinary files.  If ACTION is skip, devices are silently skipped.

       -d ACTION, --directories=ACTION
              If  an  input  file  is  a  directory, use ACTION to process it.  By default, ACTION is read, i.e., read directories just as if they were ordinary files.  If
              ACTION is skip, silently skip directories.  If ACTION is recurse, read all files under each directory, recursively, following symbolic links only if they are
              on the command line.  This is equivalent to the -r option.

       --exclude=GLOB
              Skip  any  command-line file with a name suffix that matches the pattern GLOB, using wildcard matching; a name suffix is either the whole name, or a trailing
              part that starts with a non-slash character immediately after a slash (/) in the name.  When searching recursively, skip any subfile whose base name  matches
--
       --exclude-from=FILE
              Skip files whose base name matches any of the file-name globs read from FILE (using wildcard matching as described under --exclude).

       --exclude-dir=GLOB
              Skip any command-line directory with a name suffix that matches the pattern GLOB.  When searching recursively, skip any subdirectory whose base name  matches
              GLOB.  Ignore any redundant trailing slashes in GLOB.

       -I     Process a binary file as if it did not contain matching data; this is equivalent to the --binary-files=without-match option.

       --include=GLOB
              Search only files whose base name matches GLOB (using wildcard matching as described under --exclude).

--
              Read all files under each directory, recursively.  Follow all symbolic links, unlike -r.

   Other Options
       --line-buffered
              Use line buffering on output.  This can cause a performance penalty.

       -U, --binary
              Treat the file(s) as binary.  By default, under MS-DOS and MS-Windows, grep guesses whether a file is text or binary  as  described  for  the  --binary-files
              option.   If grep decides the file is a text file, it strips the CR characters from the original file contents (to make regular expressions with ^ and $ work
              correctly).  Specifying -U overrules this guesswork, causing all files to be read and passed to the matching mechanism verbatim; if the file is a  text  file
              with CR/LF pairs at the end of each line, this will cause some regular expressions to fail.  This option has no effect on platforms other than MS-DOS and MS-
              Windows.

       -z, --null-data
              Treat input and output data as sequences of lines, each terminated by a zero byte (the ASCII NUL character) instead of a newline.   Like  the  -Z  or  --null
              option, this option can be used with commands like sort -z to process arbitrary file names.

REGULAR EXPRESSIONS
       A  regular  expression  is  a  pattern that describes a set of strings.  Regular expressions are constructed analogously to arithmetic expressions, by using various
       operators to combine smaller expressions.

--
       then it matches any character not in the list; it is unspecified whether it matches an encoding error.  For example, the regular expression [0123456789] matches any
       single digit.

       Within a bracket expression, a range expression consists of two characters separated by a hyphen.  It matches any  single  character  that  sorts  between  the  two
       characters,  inclusive, using the locale's collating sequence and character set.  For example, in the default C locale, [a-d] is equivalent to [abcd].  Many locales
       sort characters in dictionary order, and in these locales [a-d] is typically not equivalent to [abcd]; it might be equivalent to [aBbCcDd], for example.  To  obtain
       the traditional interpretation of bracket expressions, you can use the C locale by setting the LC_ALL environment variable to the value C.

       Finally,  certain  named  classes  of  characters  are predefined within bracket expressions, as follows.  Their names are self explanatory, and they are [:alnum:],
       [:alpha:], [:blank:], [:cntrl:], [:digit:], [:graph:], [:lower:], [:print:], [:punct:], [:space:], [:upper:], and [:xdigit:].  For example,  [[:alnum:]]  means  the
       character  class  of  numbers and letters in the current locale.  In the C locale and ASCII character set encoding, this is the same as [0-9A-Za-z].  (Note that the
       brackets in these class names are part of the symbolic names, and must be included in addition to the brackets  delimiting  the  bracket  expression.)   Most  meta-
       characters  lose  their  special meaning inside bracket expressions.  To include a literal ] place it first in the list.  Similarly, to include a literal ^ place it
       anywhere but first.  Finally, to include a literal - place it last.

   Anchoring
       The caret ^ and the dollar sign $ are meta-characters that respectively match the empty string at the beginning and end of a line.

   The Backslash Character and Special Expressions
       The symbols \< and \> respectively match the empty string at the beginning and end of a word.  The symbol \b matches the empty string at the edge of a word, and  \B
       matches the empty string provided it's not at the edge of a word.  The symbol \w is a synonym for [_[:alnum:]] and \W is a synonym for [^_[:alnum:]].

   Repetition
       A regular expression may be followed by one of several repetition operators:
--
       set  specifies  the  locale.   For  example, if LC_ALL is not set, but LC_MESSAGES is set to pt_BR, then the Brazilian Portuguese locale is used for the LC_MESSAGES
       category.  The C locale is used if none of these environment variables are set, if the locale catalog is not installed, or if grep was not  compiled  with  national
       language support (NLS).  The shell command locale -a lists locales that are currently available.

       GREP_OPTIONS
              This  variable  specifies default options to be placed in front of any explicit options.  As this causes problems when writing portable scripts, this feature
              will be removed in a future release of grep, and grep warns if it is used.  Please use an alias or script instead.

       GREP_COLOR
              This variable specifies the color used to highlight matched (non-empty) text.  It is deprecated in favor of GREP_COLORS, but still supported.   The  mt,  ms,
              and  mc  capabilities of GREP_COLORS have priority over it.  It can only specify the color used to highlight the matching non-empty text in any matching line
--
              also  determines  the character encoding, that is, whether text is encoded in UTF-8, ASCII, or some other encoding.  In the C or POSIX locale, all characters
              are encoded as a single byte and every byte is a valid character.

       LC_ALL, LC_MESSAGES, LANG
              These variables specify the locale for the LC_MESSAGES category, which determines the language that grep uses  for  messages.   The  default  C  locale  uses
              American English messages.

       POSIXLY_CORRECT
              If  set,  grep  behaves  as POSIX requires; otherwise, grep behaves more like other GNU programs.  POSIX requires that options that follow file names must be
              treated as file names; by default, such options are permuted to the front of the operand list  and  are  treated  as  options.   Also,  POSIX  requires  that
              unrecognized  options be diagnosed as “illegal”, but since they are not really against the law the default is to diagnose them as “invalid”.  POSIXLY_CORRECT
--
       Copyright 1998-2000, 2002, 2005-2020 Free Software Foundation, Inc.

       This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

BUGS
   Reporting Bugs
       Email  bug  reports  to  the  bug-reporting  address  ⟨bug-grep@gnu.org⟩.   An  email  archive  ⟨https://lists.gnu.org/mailman/listinfo/bug-grep⟩  and a bug tracker
       ⟨https://debbugs.gnu.org/cgi/pkgreport.cgi?package=grep⟩ are available.

   Known Bugs
       Large repetition counts in the {n,m} construct may cause grep to use lots of memory.  In addition, certain other obscure  regular  expressions  require  exponential
       time and space, and may cause grep to run out of memory.

--
   Full Documentation
       A complete manual ⟨https://www.gnu.org/software/grep/manual/⟩ is available.  If the info and grep programs are properly installed at your site, the command

              info grep

       should give you access to the complete manual.

GNU grep 3.4                                                                     2019-12-29                                                                         GREP(1)
FIND(1)                                                                   General Commands Manual                                                                   FIND(1)

NAME
       find - search for files in a directory hierarchy

SYNOPSIS
       find [-H] [-L] [-P] [-D debugopts] [-Olevel] [starting-point...] [expression]

DESCRIPTION
       This  manual  page  documents  the GNU version of find.  GNU find searches the directory tree rooted at each given starting-point by evaluating the given expression
       from left to right, according to the rules of precedence (see section OPERATORS), until the outcome is known (the left hand side is false for and  operations,  true
--
       should read the `Security Considerations' chapter of the findutils documentation, which is called Finding Files and comes with findutils.  That  document  also  in‐
       cludes a lot more detail and discussion than this manual page, so you may find it a more useful source of information.

OPTIONS
       The -H, -L and -P options control the treatment of symbolic links.  Command-line arguments following these are taken to be names of files or directories to be exam‐
       ined, up to the first argument that begins with `-', or the argument `(' or `!'.  That argument and any following arguments are taken to be the expression  describ‐
       ing  what  is  to  be searched for.  If no paths are given, the current directory is used.  If no expression is given, the expression -print is used (but you should
       probably consider using -print0 instead, anyway).

       This manual page talks about `options' within the expression list.  These options control the behaviour of find but are specified immediately after  the  last  path
       name.   The  five  `real' options -H, -L, -P, -D and -O must appear before the first path name, if at all.  A double dash -- can also be used to signal that any re‐
--
       -L     Follow symbolic links.  When find examines or prints information about files, the information used shall be taken from the properties of the  file  to  which
              the  link points, not from the link itself (unless it is a broken symbolic link or find is unable to examine the file to which the link points).  Use of this
              option implies -noleaf.  If you later use the -P option, -noleaf will still be in effect.  If -L is in effect and find discovers a symbolic link to a  subdi‐
              rectory during its search, the subdirectory pointed to by the symbolic link will be searched.

              When  the  -L option is in effect, the -type predicate will always match against the type of the file that a symbolic link points to rather than the link it‐
              self (unless the symbolic link is broken).  Actions that can cause symbolic links to become broken while find is executing (for  example  -delete)  can  give
              rise to confusing behaviour.  Using -L causes the -lname and -ilname predicates always to return false.

       -H     Do not follow symbolic links, except while processing the command line arguments.  When find examines or prints information about files, the information used
              shall be taken from the properties of the symbolic link itself.  The only exception to this behaviour is when a file specified on the command line is a  sym‐
              bolic  link,  and  the  link  can be resolved.  For that situation, the information used is taken from whatever the link points to (that is, the link is fol‐
              lowed).  The information about the link itself is used as a fallback if the file pointed to by the symbolic link cannot be examined.  If -H is in effect  and
              one of the paths specified on the command line is a symbolic link to a directory, the contents of that directory will be examined (though of course -maxdepth
              0 would prevent this).

       If more than one of -H, -L and -P is specified, each overrides the others; the last one appearing on the command line takes effect.  Since it is the default, the -P
       option should be considered to be in effect unless either -H or -L is specified.

       GNU find frequently stats files during the processing of the command line itself, before any searching has begun.  These options also affect how those arguments are
       processed.  Specifically, there are a number of tests that compare files listed on the command line against a file we are currently considering.  In each case,  the
       file  specified  on the command line will have been examined and some of its properties will have been saved.  If the named file is in fact a symbolic link, and the
--
              separated.   Compatibility  of the debug options is not guaranteed between releases of findutils.  For a complete list of valid debug options, see the output
              of find -D help.  Valid debug options include

              exec   Show diagnostic information relating to -exec, -execdir, -ok and -okdir

              opt    Prints diagnostic information relating to the optimisation of the expression tree; see the -O option.

              rates  Prints a summary indicating how often each predicate succeeded or failed.

              search Navigate the directory tree verbosely.

--
                     to stat the file first.  If you use the -fstype FOO predicate and specify a filesystem type FOO which is not known (that is, present  in  `/etc/mtab')
                     at the time find starts, that predicate is equivalent to -false.

              3      At  this  optimisation level, the full cost-based query optimiser is enabled.  The order of tests is modified so that cheap (i.e. fast) tests are per‐
                     formed first and more expensive ones are performed later, if necessary.  Within each cost band, predicates are evaluated earlier or later according to
                     whether  they  are  likely  to succeed or not.  For -o, predicates which are likely to succeed are evaluated earlier, and for -a, predicates which are
                     likely to fail are evaluated earlier.

              The cost-based optimiser has a fixed idea of how likely any given test is to succeed.  In some cases the probability takes account of the specific nature  of
              the test (for example, -type f is assumed to be more likely to succeed than -type c).  The cost-based optimiser is currently being evaluated.  If it does not
              actually improve the performance of find, it will be removed again.  Conversely, optimisations that prove to be reliable, robust and effective may be enabled
              at  lower  optimisation  levels  over time.  However, the default behaviour (i.e. optimisation level 1) will not be changed in the 4.3.x release series.  The
              findutils test suite runs all the tests on find at each optimisation level and ensures that the result is the same.

EXPRESSION
       The part of the command line after the list of starting points is the expression.  This is a kind of query specification describing how we match files and  what  we
--
       -d     A synonym for -depth, for compatibility with FreeBSD, NetBSD, MacOS X and OpenBSD.

       -depth Process each directory's contents before the directory itself.  The -delete action also implies -depth.

       -help, --help
              Print a summary of the command-line usage of find and exit.

       -ignore_readdir_race
              Normally,  find  will emit an error message when it fails to stat a file.  If you give this option and a file is deleted between the time find reads the name
              of the file from the directory and the time it tries to stat the file, no error message will be issued.  This also applies  to  files  or  directories  whose
              names  are  given  on  the  command  line.  This option takes effect at the time the command line is read, which means that you cannot search one part of the
--
              Furthermore,  find with the -ignore_readdir_race option will ignore errors of the -delete action in the case the file has disappeared since the parent direc‐
              tory was read: it will not output an error diagnostic, and the return code of the -delete action will be true.

       -maxdepth levels
              Descend at most levels (a non-negative integer) levels of directories below the starting-points.  -maxdepth 0 means only apply the tests and actions  to  the
              starting-points themselves.

       -mindepth levels
              Do not apply any tests or actions at levels less than levels (a non-negative integer).  -mindepth 1 means process all files except the starting-points.

       -mount Don't descend directories on other filesystems.  An alternate name for -xdev, for compatibility with some other versions of find.
--
              that do not follow the Unix directory-link convention, such as CD-ROM or MS-DOS filesystems or AFS volume mount points.  Each  directory  on  a  normal  Unix
              filesystem has at least 2 hard links: its name and its `.' entry.  Additionally, its subdirectories (if any) each have a `..' entry linked to that directory.
              When find is examining a directory, after it has statted 2 fewer subdirectories than the directory's link count, it knows that the rest of the entries in the
              directory  are non-directories (`leaf' files in the directory tree).  If only the files' names need to be examined, there is no need to stat them; this gives
              a significant increase in search speed.

       -version, --version
              Print the find version number and exit.

       -xdev  Don't descend directories on other filesystems.

--
              File was last accessed n minutes ago.

       -anewer reference
              Time  of  the  last access of the current file is more recent than that of the last data modification of the reference file.  If reference is a symbolic link
              and the -H option or the -L option is in effect, then the time of the last data modification of the file it points to is always used.

       -atime n
              File was last accessed n*24 hours ago.  When find figures out how many 24-hour periods ago the file was last accessed, any fractional part is ignored, so  to
              match -atime +1, a file has to have been accessed at least two days ago.

       -cmin n
              File's status was last changed n minutes ago.

       -cnewer reference
              Time  of the last status change of the current file is more recent than that of the last data modification of the reference file.  If reference is a symbolic
              link and the -H option or the -L option is in effect, then the time of the last data modification of the file it points to is always used.

       -ctime n
              File's status was last changed n*24 hours ago.  See the comments for -atime to understand how rounding affects  the  interpretation  of  file  status  change
              times.

       -empty File is empty and is either a regular file or a directory.

       -executable
              Matches  files  which are executable and directories which are searchable (in a file name resolution sense) by the current user.  This takes into account ac‐
              cess control lists and other permissions artefacts which the -perm test ignores.  This test makes use of the access(2) system call, and so can be  fooled  by
              NFS servers which do UID mapping (or root-squashing), since many systems implement access(2) in the client's kernel and so cannot make use of the UID mapping
              information held on the server.  Because this test is based only on the result of the access(2) system call, there is no guarantee that a file for which this
              test succeeds can actually be executed.

       -false Always false.

       -fstype type
              File  is on a filesystem of type type.  The valid filesystem types vary among different versions of Unix; an incomplete list of filesystem types that are ac‐
              cepted on some version of Unix or another is: ufs, 4.2, 4.3, nfs, tmp, mfs, S51K, S52K.  You can use -printf with the %F directive to see the types  of  your
              filesystems.

       -gid n File's numeric group ID is n.

       -group gname
              File belongs to group gname (numeric group ID allowed).

       -ilname pattern
              Like  -lname,  but  the  match is case insensitive.  If the -L option or the -follow option is in effect, this test returns false unless the symbolic link is
              broken.

       -iname pattern
              Like -name, but the match is case insensitive.  For example, the patterns `fo*' and `F??' match the file names `Foo', `FOO', `foo', `fOo', etc.  The  pattern
              `*foo*` will also match a file called '.foobar'.

       -inum n
              File has inode number n.  It is normally easier to use the -samefile test instead.

       -ipath pattern
              Like -path.  but the match is case insensitive.

       -iregex pattern
              Like -regex, but the match is case insensitive.

       -iwholename pattern
              See -ipath.  This alternative is less portable than -ipath.

--
              File has n hard links.

       -lname pattern
              File  is  a symbolic link whose contents match shell pattern pattern.  The metacharacters do not treat `/' or `.' specially.  If the -L option or the -follow
              option is in effect, this test returns false unless the symbolic link is broken.

       -mmin n
              File's data was last modified n minutes ago.

       -mtime n
              File's data was last modified n*24 hours ago.  See the comments for -atime to understand how rounding affects the interpretation of file modification times.

       -name pattern
              Base of file name (the path with the leading directories removed) matches shell pattern pattern.  Because the leading directories are removed, the file names
              considered  for  a match with -name will never include a slash, so `-name a/b' will never match anything (you probably need to use -path instead).  A warning
              is issued if you try to do this, unless the environment variable POSIXLY_CORRECT is set.  The metacharacters (`*', `?', and `[]') match a `.' at the start of
              the  base  name  (this  is  a  change in findutils-4.2.2; see section STANDARDS CONFORMANCE below).  To ignore a directory and the files under it, use -prune
              rather than checking every file in the tree; see an example in the description of that action.  Braces are not recognised as being special, despite the  fact
              that some shells including Bash imbue braces with a special meaning in shell patterns.  The filename matching is performed with the use of the fnmatch(3) li‐
              brary function.  Don't forget to enclose the pattern in quotes in order to protect it from expansion by the shell.

       -newer reference
              Time of the last data modification of the current file is more recent than that of the last data modification of the reference file.  If reference is a  sym‐
              bolic link and the -H option or the -L option is in effect, then the time of the last data modification of the file it points to is always used.

       -newerXY reference
              Succeeds  if  timestamp X of the file being considered is newer than timestamp Y of the file reference.  The letters X and Y can be any of the following let‐
--
              File name matches shell pattern pattern.  The metacharacters do not treat `/' or `.' specially; so, for example,
                        find . -path "./sr*sc"
              will print an entry for a directory called `./src/misc' (if one exists).  To ignore a whole directory tree, use -prune rather than checking every file in the
              tree.  Note that the pattern match test applies to the whole file name, starting from one of the start points named on the command line.  It would only  make
              sense to use an absolute path name here if the relevant start point is also an absolute path.  This means that this command will never match anything:
                        find bar -path /foo/bar/myfile -print
              Find compares the -path argument with the concatenation of a directory name and the base name of the file it's examining.  Since the concatenation will never
              end with a slash, -path arguments ending in a slash will match nothing (except perhaps a start point specified on the command line).  The predicate -path  is
              also supported by HP-UX find and is part of the POSIX 2008 standard.

       -perm mode
              File's permission bits are exactly mode (octal or symbolic).  Since an exact match is required, if you want to use this form for symbolic modes, you may have
              to specify a rather complex mode string.  For example `-perm g=w' will only match files which have mode 0020 (that is, ones for which group write  permission
              is  the  only permission set).  It is more likely that you will want to use the `/' or `-' forms, for example `-perm -g=w', which matches any file with group
              write permission.  See the EXAMPLES section for some illustrative examples.

       -perm -mode
              All of the permission bits mode are set for the file.  Symbolic modes are accepted in this form, and this is usually the way in which you would want  to  use
              them.  You must specify `u', `g' or `o' if you use a symbolic mode.  See the EXAMPLES section for some illustrative examples.

       -perm /mode
              Any  of  the  permission  bits  mode are set for the file.  Symbolic modes are accepted in this form.  You must specify `u', `g' or `o' if you use a symbolic
              mode.  See the EXAMPLES section for some illustrative examples.  If no permission bits in mode are set, this test matches any file (the idea here  is  to  be
--
              nores.  This test makes use of the access(2) system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing),  since  many  systems
              implement access(2) in the client's kernel and so cannot make use of the UID mapping information held on the server.

       -regex pattern
              File  name  matches regular expression pattern.  This is a match on the whole path, not a search.  For example, to match a file named `./fubar3', you can use
              the regular expression `.*bar.' or `.*b.*3', but not `f.*r3'.  The regular expressions understood by find are by default Emacs  Regular  Expressions  (except
              that `.' matches newline), but this can be changed with the -regextype option.

       -samefile name
              File refers to the same inode as name.  When -L is in effect, this can include symbolic links.

       -size n[cwbkMG]
              File uses n units of space, rounding up.  The following suffixes can be used:

              `b'    for 512-byte blocks (this is the default if no suffix is used)

              `c'    for bytes

              `w'    for two-byte words

              `k'    for kibibytes (KiB, units of 1024 bytes)

              `M'    for mebibytes (MiB, units of 1024 * 1024 = 1048576 bytes)
--
              File is of type c:

              b      block (buffered) special

              c      character (unbuffered) special

              d      directory

              p      named pipe (FIFO)

              f      regular file

              l      symbolic  link; this is never true if the -L option or the -follow option is in effect, unless the symbolic link is broken.  If you want to search for
                     symbolic links when -L is in effect, use -xtype.

              s      socket

              D      door (Solaris)

--
       -uid n File's numeric user ID is n.

       -used n
              File was last accessed n days after its status was last changed.

       -user uname
              File is owned by user uname (numeric user ID allowed).

       -wholename pattern
              See -path.  This alternative is less portable than -path.

       -writable
              Matches files which are writable by the current user.  This takes into account access control lists and other permissions artefacts which the -perm test  ig‐
              nores.   This  test  makes use of the access(2) system call, and so can be fooled by NFS servers which do UID mapping (or root-squashing), since many systems
              implement access(2) in the client's kernel and so cannot make use of the UID mapping information held on the server.

       -xtype c
              The same as -type unless the file is a symbolic link.  For symbolic links: if the -H or -P option was specified, true if the file is a link to a file of type
              c; if the -L option has been given, true if c is `l'.  In other words, for symbolic links, -xtype checks the type of the file that -type does not check.

       -context pattern
              (SELinux only) Security context of the file matches glob pattern.

   ACTIONS
       -delete
              Delete  files;  true if removal succeeded.  If the removal failed, an error message is issued.  If -delete fails, find's exit status will be nonzero (when it
              eventually exits).  Use of -delete automatically turns on the `-depth' option.

--
              True; like -ls but write to file like -fprint.  The output file is always created, even if the predicate is never matched.  See the UNUSUAL FILENAMES section
              for information about how unusual characters in filenames are handled.

       -fprint file
              True; print the full file name into file file.  If file does not exist when find is run, it is created; if it does exist, it is truncated.   The  file  names
              `/dev/stdout'  and `/dev/stderr' are handled specially; they refer to the standard output and standard error output, respectively.  The output file is always
              created, even if the predicate is never matched.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.

       -fprint0 file
              True; like -print0 but write to file like -fprint.  The output file is always created, even if the predicate is never matched.   See  the  UNUSUAL  FILENAMES
              section for information about how unusual characters in filenames are handled.

       -fprintf file format
              True;  like  -printf  but  write to file like -fprint.  The output file is always created, even if the predicate is never matched.  See the UNUSUAL FILENAMES
              section for information about how unusual characters in filenames are handled.

       -ls    True; list current file in ls -dils format on standard output.  The block counts are of 1 KB blocks, unless the environment variable POSIXLY_CORRECT is  set,
              in which case 512-byte blocks are used.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.

       -ok command ;
              Like  -exec  but  ask the user first.  If the user agrees, run the command.  Otherwise just return false.  If the command is run, its standard input is redi‐
              rected from /dev/null.

              The response to the prompt is matched against a pair of regular expressions to determine if it is an affirmative or negative response.  This regular  expres‐
              sion  is  obtained from the system if the `POSIXLY_CORRECT' environment variable is set, or otherwise from find's message translations.  If the system has no
              suitable definition, find's own definition will be used.  In either case, the interpretation of the regular expression itself will be affected by  the  envi‐
              ronment variables 'LC_CTYPE' (character classes) and 'LC_COLLATE' (character ranges and equivalence classes).

--
              of -print.  See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.

       -print0
              True; print the full file name on the standard output, followed by a null character (instead of the newline character that -print uses).   This  allows  file
              names  that  contain newlines or other types of white space to be correctly interpreted by programs that process the find output.  This option corresponds to
              the -0 option of xargs.

       -printf format
              True; print format on the standard output, interpreting `\' escapes and `%' directives.  Field widths and precisions can be specified as with the `printf'  C
              function.   Please  note  that  many  of the fields are printed as %s rather than %d, and this may mean that flags don't work as you might expect.  This also
              means that the `-' flag does work (it forces fields to be left-aligned).  Unlike -print, -printf does not add a newline at the end of the  string.   The  es‐
              capes and directives are:

              \a     Alarm bell.

              \b     Backspace.

              \c     Stop printing from this format immediately and flush the output.

              \f     Form feed.

              \n     Newline.

              \r     Carriage return.

              \t     Horizontal tab.

              \v     Vertical tab.

              \0     ASCII NUL.
--
              %a     File's last access time in the format returned by the C `ctime' function.

              %Ak    File's last access time in the format specified by k, which is either `@' or a directive for the C `strftime' function.  The possible values for k are
                     listed below; some of them might not be available on all systems, due to differences in `strftime' between systems.

                     @      seconds since Jan. 1, 1970, 00:00 GMT, with fractional part.

                     Time fields:

                     H      hour (00..23)

                     I      hour (01..12)

--
              %c     File's last status change time in the format returned by the C `ctime' function.

              %Ck    File's last status change time in the format specified by k, which is the same as for %A.

              %d     File's depth in the directory tree; 0 means the file is a starting-point.

              %D     The device number on which the file exists (the st_dev field of struct stat), in decimal.

              %f     File's name with any leading directories removed (only the last element).

              %F     Type of the filesystem the file is on; this value can be used for -fstype.

              %g     File's group name, or numeric group ID if the group has no name.

              %G     File's numeric group ID.

              %h     Leading  directories  of  file's  name (all but the last element).  If the file name contains no slashes (since it is in the current directory) the %h
                     specifier expands to `.'.

              %H     Starting-point under which file was found.

              %i     File's inode number (in decimal).

              %k     The amount of disk space used for this file in 1 KB blocks.  Since disk space is allocated in multiples of the filesystem block size this  is  usually
                     greater than %s/1024, but it can also be smaller if the file is a sparse file.

              %l     Object of symbolic link (empty string if file is not a symbolic link).

              %m     File's permission bits (in octal).  This option uses the `traditional' numbers which most Unix implementations use, but if your particular implementa‐
                     tion uses an unusual ordering of octal permissions bits, you will see a difference between the actual value of the file's mode and the output  of  %m.
                     Normally you will want to have a leading zero on this number, and to do this, you should use the # flag (as in, for example, `%#m').

              %M     File's permissions (in symbolic form, as for ls).  This directive is supported in findutils 4.2.5 and later.

              %n     Number of hard links to file.

              %p     File's name.

              %P     File's name with the name of the starting-point under which it was found removed.

              %s     File's size in bytes.

              %S     File's  sparseness.   This is calculated as (BLOCKSIZE*st_blocks / st_size).  The exact value you will get for an ordinary file of a certain length is
                     system-dependent.  However, normally sparse files will have values less than 1.0, and files which use indirect  blocks  may  have  a  value  which  is
                     greater  than 1.0.  In general the number of blocks used by a file is file system dependent.  The value used for BLOCKSIZE is system-dependent, but is
                     usually 512 bytes.  If the file size is zero, the value printed is undefined.  On systems which lack support for st_blocks, a file's sparseness is as‐
                     sumed to be 1.0.

              %t     File's last modification time in the format returned by the C `ctime' function.

              %Tk    File's last modification time in the format specified by k, which is the same as for %A.

              %u     File's user name, or numeric user ID if the user has no name.

              %U     File's numeric user ID.

              %y     File's type (like in ls -l), U=unknown type (shouldn't happen)

              %Y     File's type (like %y), plus follow symlinks: `L'=loop, `N'=nonexistent, `?' for any other error when determining the type of the symlink target.

              %Z     (SELinux only) file's security context.

              %{ %[ %(
                     Reserved for future use.

              A `%' character followed by any other character is discarded, but the other character is printed (don't rely on this, as further format characters may be in‐
              troduced).  A `%' at the end of the format argument causes undefined behaviour since there is no following character.  In some locales, it may hide your door
              keys, while in others it may remove the final page from the novel you are reading.

--
              See the UNUSUAL FILENAMES section for information about how unusual characters in filenames are handled.

       -prune True;  if  the  file is a directory, do not descend into it.  If -depth is given, then -prune has no effect.  Because -delete implies -depth, you cannot use‐
              fully use -prune and -delete together.
                For example, to skip the directory `src/emacs' and all files and directories under it, and print the names of the other  files  found,  do  something  like
              this:
                        find . -path ./src/emacs -prune -o -print

       -quit  Exit  immediately.   No  child processes will be left running, but no more paths specified on the command line will be processed.  For example, find /tmp/foo
              /tmp/bar -print -quit will print only /tmp/foo.  Any command lines which have been built up with -execdir ... {} + will be invoked before  find  exits.   The
              exit status may or may not be zero, depending on whether an error has already occurred.

   OPERATORS
       Listed in order of decreasing precedence:

       ( expr )
              Force  precedence.   Since  parentheses  are  special to the shell, you will normally need to quote them.  Many of the examples in this manual page use back‐
              slashes for this purpose: `\(...\)' instead of `(...)'.

       ! expr True if expr is false.  This character will also usually need protection from interpretation by the shell.

       -not expr
              Same as ! expr, but not POSIX compliant.

       expr1 expr2
              Two expressions in a row are taken to be joined with an implied -a; expr2 is not evaluated if expr1 is false.

--
UNUSUAL FILENAMES
       Many  of  the  actions of find result in the printing of data which is under the control of other users.  This includes file names, sizes, modification times and so
       forth.  File names are a potential problem since they can contain any character except `\0' and `/'.  Unusual characters in file names can do unexpected  and  often
       undesirable  things  to  your  terminal (for example, changing the settings of your function keys on some terminals).  Unusual characters are handled differently by
       various actions, as described below.

       -print0, -fprint0
              Always print the exact filename, unchanged, even if the output is going to a terminal.

       -ls, -fls
              Unusual characters are always escaped.  White space, backslash, and double quote characters are printed using C-style  escaping  (for  example  `\f',  `\"').
              Other  unusual  characters  are  printed  using an octal escape.  Other printable characters (for -ls and -fls these are the characters between octal 041 and
              0176) are printed as-is.
--
              If the output is not going to a terminal, it is printed as-is.  Otherwise, the result depends on which directive is in use.  The directives %D, %F,  %g,  %G,
              %H,  %Y,  and %y expand to values which are not under control of files' owners, and so are printed as-is.  The directives %a, %b, %c, %d, %i, %k, %m, %M, %n,
              %s, %t, %u and %U have values which are under the control of files' owners but which cannot be used to send arbitrary data to the terminal, and so these  are
              printed  as-is.   The  directives  %f,  %h, %l, %p and %P are quoted.  This quoting is performed in the same way as for GNU ls.  This is not the same quoting
              mechanism as the one used for -ls and -fls.  If you are able to decide what format to use for the output of find then it is normally better to use `\0' as  a
              terminator  than to use newline, as file names can contain white space and newline characters.  The setting of the `LC_CTYPE' environment variable is used to
              determine which characters need to be quoted.

       -print, -fprint
              Quoting is handled in the same way as for -printf and -fprintf.  If you are using find in a script or in a situation where the matched files might have arbi‐
              trary names, you should consider using -print0 instead of -print.
--
STANDARDS CONFORMANCE
       For  closest  compliance  to the POSIX standard, you should set the POSIXLY_CORRECT environment variable.  The following options are specified in the POSIX standard
       (IEEE Std 1003.1-2008, 2016 Edition):

       -H     This option is supported.

       -L     This option is supported.

       -name  This option is supported, but POSIX conformance depends on the POSIX conformance of the system's fnmatch(3) library function.  As of  findutils-4.2.2,  shell
              metacharacters  (`*',  `?' or `[]' for example) will match a leading `.', because IEEE PASC interpretation 126 requires this.  This is a change from previous
              versions of findutils.

       -type  Supported.  POSIX specifies `b', `c', `d', `l', `p', `f' and `s'.  GNU find also supports `D', representing a Door, where the OS  provides  these.   Further‐
              more, GNU find allows multiple types to be specified at once in a comma-separated list.

       -ok    Supported.   Interpretation of the response is according to the `yes' and `no' patterns selected by setting the `LC_MESSAGES' environment variable.  When the
              `POSIXLY_CORRECT' environment variable is set, these patterns are taken system's definition of a positive (yes) or negative (no) response.  See the  system's
              documentation  for  nl_langinfo(3), in particular YESEXPR and NOEXPR.  When `POSIXLY_CORRECT' is not set, the patterns are instead taken from find's own mes‐
              sage catalogue.

       -newer Supported.  If the file specified is a symbolic link, it is always dereferenced.  This is a change from previous behaviour, which used to take  the  relevant
              time from the symbolic link; see the HISTORY section below.

--
              the section UNUSUAL FILENAMES.

       LC_MESSAGES
              Determines  the locale to be used for internationalised messages.  If the `POSIXLY_CORRECT' environment variable is set, this also determines the interpreta‐
              tion of the response to the prompt made by the -ok action.

       NLSPATH
              Determines the location of the internationalisation message catalogues.

       PATH   Affects the directories which are searched to find the executables invoked by -exec, -execdir, -ok and -okdir.

--
       Find  files  named core in or below the directory /tmp and delete them.  Note that this will work incorrectly if there are any filenames containing newlines, single
       or double quotes, or spaces.

       find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f

       Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing  single  or  double
       quotes, spaces or newlines are correctly handled.  The -name test comes before the -type test in order to avoid having to call stat(2) on every file.

       find . -type f -exec file '{}' \;

       Runs `file' on every file in or below the current directory.  Notice that the braces are enclosed in single quote marks to protect them from interpretation as shell
       script punctuation.  The semicolon is similarly protected by the use of a backslash, though single quotes could have been used in that case also.

       find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \
       \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)

--
       Search for files which have read and write permission for their owner, and group, but which other users can read but not write to.  Files which meet these  criteria
       but have other permissions bits set (for example if someone can execute the file) will not be matched.

       find . -perm -664

       Search for files which have read and write permission for their owner and group, and which other users can read, without regard to the presence of any extra permis‐
       sion bits (for example the executable bit).  This will match a file which has mode 0777, for example.

       find . -perm /222

       Search for files which are writable by somebody (their owner, or their group, or anybody else).
--
       When  some  error  occurs, find may stop immediately, without completing all the actions specified.  For example, some starting points may not have been examined or
       some pending program invocations for -exec ... {} + or -execdir ... {} + may not have been performed.

SEE ALSO
       locate(1), locatedb(5), updatedb(1), xargs(1), chmod(1), fnmatch(3), regex(7), stat(2), lstat(2), ls(1), printf(3), strftime(3), ctime(3)

       The full documentation for find is maintained as a Texinfo manual.  If the info and find programs are properly installed at your site, the command info find  should
       give you access to the complete manual.

HISTORY
       As of findutils-4.2.2, shell metacharacters (`*', `?' or `[]' for example) used in filename patterns will match a leading `.', because IEEE POSIX interpretation 126
--
       Feature                Added in   Also occurs in
       -newerXY               4.3.3      BSD
       -D                     4.3.1
       -O                     4.3.1
       -readable              4.3.0
       -writable              4.3.0
       -executable            4.3.0
       -regextype             4.2.24
       -exec ... +            4.2.12     POSIX
       -execdir               4.2.12     BSD
       -okdir                 4.2.12
--
       Copyright © 1990-2019 Free Software Foundation, Inc.  License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
       This is free software: you are free to change and redistribute it.  There is NO WARRANTY, to the extent permitted by law.

BUGS
       There are security problems inherent in the behaviour that the POSIX standard specifies for find, which therefore cannot be fixed.  For example, the -exec action is
       inherently insecure, and -execdir should be used instead.  Please see Finding Files for more information.

       The environment variable LC_COLLATE has no effect on the -ok action.

       The  best  way  to  report  a  bug is to use the form at https://savannah.gnu.org/bugs/?group=findutils.  The reason for this is that you will then be able to track
       progress in fixing the problem.  Other comments about find(1) and about the findutils package in general can be sent to the bug-findutils mailing list.  To join the
       list, send email to bug-findutils-request@gnu.org.

                                                                                                                                                                    FIND(1)
